## 计算机图形学基本知识点

参考书目：《计算机图形学（第四版）》

> 额外的可能有用的链接：
>
> - [计算几何中与多边形相关的基本问题 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/611632120)
> - 补充:gluPerspective和gluLookAt函数的介绍:https://blog.csdn.net/dcrmg/article/details/53106457

注：以下注释部分总结的是还没有认真看完的书对应小节，在有需要的时候再去看：

> 注：还未认真看的小节
>
> - 4.7.8 前向面与后向面

## 一、环境配置

Glut包可以通过在VS 2019中工具->NuGet包管理器中搜索FreeGlut包进行下载得到。

### 1.Hello World

接下来，我们来书写第一个OpenGL程序（使用GLUT，效果是绘制一条线段）：

```glsl
#include<GL/glut.h>
void init()
{
	glClearColor(1.0, 1.0, 1.0, 0.0); //set display-window color to white
	glMatrixMode(GL_PROJECTION);
	gluOrtho2D(0.0, 200.0, 0.0, 150.0);
}

void lineSegment() //显示回调函数
{
	glClear(GL_COLOR_BUFFER_BIT);
	glColor3f(0.0, 0.4, 0.2);
	glBegin(GL_LINES);
		glVertex2i(180, 15);
		glVertex2i(10, 145);
	glEnd();
	glFlush(); //process all opengl routines as quickly as possible
}

void main(int argc, char** argv)
{
	glutInit(&argc, argv);
	glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);  //GLUT_SINGLE单缓冲，屏幕显示调用glFlush(),与之对应的是熟悉的双缓冲区
	glutInitWindowPosition(50, 100); //top-left为原点,两个参数分别是第50列和第100行的位置
	glutInitWindowSize(400, 300);
	glutCreateWindow("An example OpenGL helloworld program");

	init();
	glutDisplayFunc(lineSegment);
	glutMainLoop();
}
```

> 注：关于OpenGL的出错的Debug处理，可以参考书p33页第3.5.6节。平时输出查看结果的时候为了加快效率记得把Debug模式改为Release模式。

------

## 二、第4章 输出图元

### 1.基础知识

#### （1）凹凸多边形判断

凹凸多边形的区别：

- 凸多边形的所有内角均<180°，而凹多边形则至少有一个内角度数>180°
- 凸多边形的所有边叉积均同号，因此如果某些叉积取正值而另一些为负值，则一定是凹多边形。

------



#### （2）分割凹多边形

将凹多边形分割成一组凸多边形，可以使用以下两种方法（具体可以参考书p44页4.7.3部分）：

- **通过边向量和边叉积来完成**，简单来说就是找到每一组相邻边计算叉积结果，如果有一个叉积的方向不同于其他叉积，则多边形为凹且可以沿着对应叉积中第一边向量的直线进行切割（找到与对面边交点的方法不再赘述）。
- **通过旋转方法来进行分割**。沿多边形的边的逆时针方向，逐一将顶点$V_k$移动到坐标系原点，然后顺时针旋转多边形，使下一顶点$V_{k+1}$落在x轴上，如果再下一个顶点$V_{k+2}$在x轴下面，则为凹多边形，并可沿x轴将多边形分割成两个新多边形，并重复测试。

两种方法的示意图如下：

<img src="%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%B9%A6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A6%82%E8%A6%81.assets/image-20230909142108819.png" alt="image-20230909142108819" style="zoom:80%;" />

更多细节可以参考文章：[如何切割凹多边形 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/350994427)

------



#### （3）将凸多边形分割成三角形集

一种简单的方法是将任意顺序的3个连续顶点定义为一个新三角形，然后将三角形的中间顶点从多边形原顶点队列中删除，接着重复进行上述操作即可。**至于如何求解分割的最优解应该是有一个算法，有遇到再在这里进行总结。**

------



#### （4）内-外测试

- 识别**平面图形**的内部区域的两种常用方法：奇偶规则和非零环绕数规则
  - 奇偶规则：从任意位置P到对象坐标范围以外的远点画一条概念上的射线（该射线不能与多边形的顶点相交），记录与多边形边相交的数量。如果为奇数则在内部，否则在外部。
  - 非零环绕数规则：[非零环绕数规则和奇-偶规则（Non-Zero Winding Number Rule & Odd-even Rule） - 简书 (jianshu.com)](https://www.jianshu.com/p/9fd7b2fc51c7)。在代码实现上，用非零环绕数的话可以依旧用叉乘进行判断。除此之外，还可以用点乘进行判断，具体可以看书p47，有需要再总结；

注意，针对比较复杂的情况，两种方法可能会给出不同的判断结果。

------



#### （5）数学补充——克拉默法则

[克拉默法则 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/57944485)

------



### 2.OpenGL相关

#### （1）OpenGL多边形填充区函数

- OpenGL中的填充区必须指定为凸多边形，并且中间不能有洞。
- OpenGL提供了一个特殊的矩形函数：`glRect*(x1,y1,x2,y2);`，表示该矩形的一个角位于`(x1,y1)`,另一个角位于`(x2,y2)`。



#### （2）OpenGL顶点数组

接下来，我们以绘制正方体为例，介绍顶点数组的基本概念和用法。

首先，如果我们要按照传统的方式绘制正方体，可能会写出这样的代码：
```glsl
#include<GL/glut.h>
#include<iostream>
using namespace std;

typedef float vertex3[3];
vertex3 pt[8] = { {-0.5f,-0.5f,-0.5f},{0.5f,-0.5f,-0.5f},{-0.5f,-0.5f,0.5f},{0.5f,-0.5f,0.5f},
				 {-0.5f,0.5f,-0.5f},{0.5f,0.5f,-0.5f},{-0.5f,0.5f,0.5f},{0.5f,0.5f,0.5f} };

static float rotate1 = 0;

static int times = 0;



void quad(GLint n1, GLint n2, GLint n3, GLint n4)
{
	//note:必须明确每一个面的顶点顺序符合从立方体外部对其观察时为逆时针次序的要求
	glBegin(GL_QUADS); //生成不相连的四边形,除非重复写顶点
		glVertex3fv(pt[n1]);
		glVertex3fv(pt[n2]);
		glVertex3fv(pt[n3]);
		glVertex3fv(pt[n4]);
	glEnd();
}

void drawCube()
{
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
	glMatrixMode(GL_MODELVIEW); //模型空间下物体进行旋转
	glLoadIdentity();
	glPushMatrix();  //注意,旋转等操作代码写在PushMatrix和PopMatrix之间

	//立方体随着时间进行旋转
	times++;
	if (times > 100)
	{
		times = 0;
	}

	if (times % 100 == 0)
	{
		rotate1 += 0.3;
	}

	glRotatef(rotate1, 0, 1, 0);
	glRotatef(rotate1, 1, 0, 0);

	glColor3f(0.0, 0.4, 0.2);
	//下述顶点的索引示意图见下
	quad(6, 2, 3, 7);
	quad(5, 1, 0, 4);
	quad(7, 3, 1, 5);
	quad(4, 0, 2, 6);
	quad(2, 0, 1, 3);
	quad(7, 5, 4, 6);
	glPopMatrix();
	glutSwapBuffers();

}

//main函数与前面的示例代码一致
void main(int argc, char** argv)
{
	glutInit(&argc, argv);
	glutInitDisplayMode(GLUT_DEPTH | GLUT_DOUBLE | GLUT_RGBA); 
	glutInitWindowSize(500, 500);
	glutCreateWindow("Draw Cube");

	glutDisplayFunc(drawCube);
	glutIdleFunc(drawCube);
	glutMainLoop();
}
```

对应的立方体编号如书中p56页的图所示，可以看到要重复书写很多的`quad()`函数，这对于更复杂的场景来说是不能接受的。OpenGL为此提供了**使用顶点数组**的解决办法，具体需要对代码做出如下修改：

```glsl
void drawCube()
{
	//note：其余的代码不变
    glColor3f(0.0, 0.4, 0.2);
	//新增代码:使用顶点数组
	glEnableClientState(GL_VERTEX_ARRAY); //启用顶点数组的能力.需要在客户端启用
	glVertexPointer(3, GL_FLOAT, 0, pt);  //3是每一个顶点描述中的坐标数目,0是连续顶点之间的字节位移
	GLubyte vertexIndex[] = { 6,2,3,7,5,1,0,4,7,3,1,5,4,0,2,6,2,0,1,3,7,5,4,6 }; //每4个为一组，用来指绘制quad的索引
	glDrawElements(GL_QUADS, 24, GL_UNSIGNED_BYTE, vertexIndex);
}
```

**注：关于绘制正六边形的程序以及绘制曲线的程序，直接看LearnOpenGL.sln文件查看即可。**

------



## 三、第5章 第6章 图元的属性以及实现的算法

- RGB生成灰度图的方法：R=G=B，并且靠近0生成暗灰色，靠近1生成亮灰色。
- 在OpenGL内部，颜色信息用浮点数表示。

### 1.画线算法

参考资料：[DDA算法和Bresenham算法_两鬓已不能斑白的博客-CSDN博客](https://blog.csdn.net/u010429424/article/details/77834046)

#### （1）DDA算法

> DDA算法是计算机图形学中最简单的绘制直线算法。其主要思想是由直线公式y = kx + b推导出来的。
> 我们已知直线段两个端点P0(x0,y0)和P1(x1,y1)，就能求出 k 和 b 。
>
> 在k，b均求出的条件下，只要知道一个x值，我们就能计算出一个y值。如果x的步进为1（x每次加1，即x = x +1），那么y的步进就为k+b；同样知道一个y值也能计算出x值，此时y的步进为1，x的步进为(1-b)/k。根据计算出的x值和y值，向下取整，得到坐标(x’,y’)，并在(x’,y’)处绘制直线段上的一点。
>
> 为进一步简化计算，通常可令b取0，将起点看作(0,0)。设当前点为(xi, yi)则用DDA算法求解(xi+1，yi+1)的计算公式可以概括为：
>
> - xi+1 = xi + xStep (1)
> - yi+1 = yi + yStep (2)
>
> 我们一般通过计算 Δx 和 Δy 来确定xStep和yStep：
>
> - 如果 Δx > Δy ，说明x轴的最大差值大于y轴的最大差值，x轴方向为步进的主方向，xStep = 1，yStep = k；
> - 如果 Δy> Δx，说明y轴的最大差值大于x轴的最大差值，y轴方向为步进的主方向，yStep = 1，xStep = 1 / k。
>
> 根据这个公式，就能通过(xi，yi)迭代计算出(xi+1、yi+1)，然后在坐标系中绘制计算出的(x,y)坐标点。